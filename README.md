# accuknox-Django-trainee-assignment

File 2:Rectangle.py (Topic: Custom Classes in Python)
When the program runs, it first creates an instance of the Rectangle class by passing two integer values — for example, length = 10 and width = 5. These values are stored as attributes of the object. Then, the class is designed to be iterable by implementing the __iter__ method. This special method allows the object to be used in a for loop. When iteration begins, Python calls the __iter__ method, which returns a generator. The generator first yields a dictionary containing the length in the format {'length': 10}, and on the next iteration, it yields another dictionary with the width in the format {'width': 5}. After both values are yielded, the iteration stops. As a result, when the user runs a for loop on the Rectangle object, they see two printed outputs—one showing the length and the other showing the width—each as a separate dictionary. This behavior demonstrates how custom classes in Python can be made iterable and customized to yield data in a specific structured format.

File 1: django_signals_demo.py (Django signals)
In Django, signals are a powerful feature that allows different parts of an application to communicate and respond to certain events or actions. Signals follow the observer design pattern, where a "sender" dispatches a signal when an action occurs (such as saving a model), and "receivers" listen for those signals to perform additional tasks. This mechanism is especially useful for decoupling logic; for example, instead of writing all the behavior inside a model’s save() method, you can trigger actions in separate parts of the code via signals.
A typical signal in Django uses the @receiver decorator from django.dispatch to register a function that listens to a specific signal, like post_save or pre_delete. For instance, you might use post_save on a Book model so that every time a book record is created or updated, a message is printed or a related task is triggered. The receiver function can access arguments like instance, created, and kwargs, giving you detailed control over the behavior when the signal is fired.
Behind the scenes, Django has a signals framework built on Python’s signal-slot system. The signals must be imported and connected properly, typically inside an apps.py file or the ready() method of your app’s configuration class to ensure they’re registered when Django starts. This avoids missing signals during runtime. Signals are commonly used for logging, sending notifications, updating related models, or triggering background tasks — all without tightly coupling the logic to the model itself.
